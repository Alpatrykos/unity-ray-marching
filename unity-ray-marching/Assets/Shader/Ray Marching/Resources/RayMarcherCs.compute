/******************************************************************************/
/*
  Project - Unity Ray Marching
            https://github.com/TheAllenChou/unity-ray-marching

  Author  - Ming-Lun "Allen" Chou
  Web     - http://AllenChou.net
  Twitter - @TheAllenChou

*/
/******************************************************************************/

#include "../SDF/SDF.cginc"

#define kTileSize (8)

Texture2D<float4> src;
RWTexture2D<float4> dst;
RWTexture2D<float> heatMap;

float4x4 cameraInvProj;
float4x4 cameraToWorld;
float4 cameraPos;
int2 screenSize; // width / height

StructuredBuffer<SdfShape> aSdfShape;
int numSdfShapes = 0;
RWTexture2D<float4> tempBuffer; // scratch memory

float4 rayMarchParams; // maxSteps, hitDist, maxDist, time
float blendDist;

float4 backgroundColor;
float4 missColor;

float4 heatColorCool;
float4 heatColorMedium;
float4 heatColorHot;
float heatAlpha;

int maxCountBudget;


// AABB tree
//-----------------------------------------------------------------------------

struct Aabb
{
  float4 boundsMin;
  float4 boundsMax;
};

struct AabbNode
{
  Aabb aabb;
  int parent;
  int childA;
  int childB;
  int shapeIndex;
};

#define kAabbStackSize (256)

StructuredBuffer<AabbNode> aabbTree;
int aabbTreeRoot;

inline float3 aabb_center(Aabb aabb)
{
  return 0.5f * (aabb.boundsMin.xyz + aabb.boundsMax.xyz);
}

inline float3 aabb_extents(Aabb aabb)
{
  return aabb.boundsMax.xyz - aabb.boundsMin.xyz;
}

inline float3 aabb_half_extents(Aabb aabb)
{
  return 0.5f * (aabb.boundsMax.xyz - aabb.boundsMin.xyz);
}

inline bool aabb_intersects(Aabb a, Aabb b)
{
  return all(a.boundsMin <= b.boundsMax && a.boundsMax >= b.boundsMin);
}

float aabb_ray_cast(Aabb aabb, float3 from, float3 to)
{
  float tMin = -kFltMax;
  float tMax = +kFltMax;

  float3 d = to - from;
  float3 absD = abs(d);

  if (any(absD < kEpsilon))
  {
    // parallel?
    if (any(from < aabb.boundsMin.xyz) || any(aabb.boundsMax.xyz < from))
      return -kFltMax;
  }
  else
  {
    float3 invD = 1.0f / d;
    float3 t1 = (aabb.boundsMin.xyz - from) * invD;
    float3 t2 = (aabb.boundsMax.xyz - from) * invD;
    float3 minComps = min(t1, t2);
    float3 maxComps = max(t1, t2);

    tMin = max(minComps.x, max(minComps.y, minComps.z));
    tMax = min(maxComps.x, min(maxComps.y, maxComps.z));
  }

  if (tMin > tMax)
    return -kFltMax;

  if (tMin < 0.0f)
    return -kFltMax;

  return tMin;
}

float3 sdf_aabb_tree_ray_cast(float3 p, float3 from, float3 to, int3 id)
{
  float3 r = normalize(to - from);

  // v is perpendicular to the segment.
  float3 v = normalize(find_ortho(r));
  float3 absV = abs(v);

  // build a bounding box for the segment.
  Aabb rayBounds;
  rayBounds.boundsMin = float4(min(from, to), 0.0f) - float4(1.0f, 1.0f, 1.0f, 1.0f);
  rayBounds.boundsMax = float4(max(from, to), 0.0f) + float4(1.0f, 1.0f, 1.0f, 1.0f);

  int stackTop = 0;
  int aabbStack[kAabbStackSize];
  aabbStack[stackTop] = aabbTreeRoot;

  float3 res = kInfinity;

  while (stackTop >= 0)
  {
    int index = aabbStack[stackTop--];
    if (index < 0)
      continue;

    if (!aabb_intersects(aabbTree[index].aabb, rayBounds))
      continue;

    // Separating axis for segment (Gino, p80).
    // |dot(v, a - c)| > dot(|v|, h)
    float3 c = aabb_center(aabbTree[index].aabb);
    float3 h = aabb_half_extents(aabbTree[index].aabb);
    float separation = abs(dot(v, from - c)) - dot(absV, h);
    if (separation > 0.0f)
      continue;

    // is leaf?
    if (aabbTree[index].childA < 0)
    {
      float t = aabb_ray_cast(aabbTree[index].aabb, from, to);
      if (t < 0.0f)
        continue;

      // why doesn't a switch state ment work here?
      int iShape = aabbTree[index].shapeIndex;
      int op = aSdfShape[iShape].data0.y;
      if (op == kSdfUnion)
      {
        res.x = sdf_uni_smooth(res.x, sdf_shape(p, aSdfShape[iShape]), blendDist);
      }
      else if (op == kSdfSubtraction)
      {
        res.y = sdf_uni_smooth(res.y, sdf_shape(p, aSdfShape[iShape]), blendDist);
      }
      else if (op == kSdfIntersection)
      {
        res.z = sdf_uni_smooth(res.z, sdf_shape(p, aSdfShape[iShape]), blendDist);
      }
    }
    else
    {
      aabbStack[++stackTop] = aabbTree[index].childA;
      aabbStack[++stackTop] = aabbTree[index].childB;
    }
  }

  return res;
}

//-----------------------------------------------------------------------------
// end: AABB tree


// ray marching
//-----------------------------------------------------------------------------

// no keyword variant support for compute shaders yet, sigh -_-
#define kModeMain       (0)
#define kModeStepCount  (1)
#define kModeShapeCount (2)

float master_sdf(float3 p, int3 id)
{
  if (numSdfShapes <= 0)
    return kInfinity;

  float3 opRes = kInfinity;

  bool useAabbTree = true;
  if (useAabbTree)
  {
    float3 ro = cameraPos.xyz;
    float3 rd = tempBuffer[id.xy];
    
    const float maxDist = rayMarchParams.z;

    opRes = sdf_aabb_tree_ray_cast(p, ro, ro + maxDist * rd, id);
  }
  else
  {
    for (int i = 0; i < numSdfShapes; ++i)
    {
      // why doesn't a switch state ment work here?
      int op = aSdfShape[i].data0.y;
      if (op == kSdfUnion)
      {
        opRes.x = sdf_uni_smooth(opRes.x, sdf_shape(p, aSdfShape[i]), blendDist);
      }
      else if (op == kSdfSubtraction)
      {
        opRes.y = sdf_uni_smooth(opRes.y, sdf_shape(p, aSdfShape[i]), blendDist);
      }
      else if (op == kSdfIntersection)
      {
        opRes.z = sdf_uni_smooth(opRes.z, sdf_shape(p, aSdfShape[i]), blendDist);
      }
    }
  }

  float res = sdf_sub_smooth(opRes.x, opRes.y, blendDist);
  if (opRes.z < kInfinity)
    res = sdf_int_smooth(res, opRes.z, blendDist);

  return res;
}

float3 heat_color(float t)
{
  return
    t < 0.5f 
      ? lerp(heatColorCool.rgb, heatColorMedium.rgb, t / 0.5f) 
      : lerp(heatColorMedium.rgb, heatColorHot.rgb, (t - 0.5f) / 0.5f);
}

float4 march(int3 id, int mode)
{
  // TODO: move hard-coded material out of here
  const float3 kDiffuse = float3(1.0f, 0.65f, 0.05f);
  const float3 kAmbient = 0.1f * kDiffuse;

  // set up ray
  float2 uv = float2(id.xy) / screenSize;
  float4 view = mul(cameraInvProj, float4(uv * 2.0f - 1.0f, 0.0f, 1.0f));
  float3 ro = cameraPos.xyz;
  float3 rd = normalize(mul(cameraToWorld, float4(view.xyz, 0.0f)).xyz);

  tempBuffer[id.xy] = float4(rd, 0.0f);
  
  // params
  const int maxSteps = int(rayMarchParams.x);
  const float hitDist = rayMarchParams.y;
  const float maxDist = rayMarchParams.z;

  // march ray
  float dist = 0.0f;
  for (int iStep = 0; iStep < maxSteps; ++iStep)
  {
    float3 p = ro + dist * rd;
    float d = master_sdf(p, id);

    // hit shape?
    if (d < hitDist)
    {
      // TODO: why doesn't a switch statement work here?
      if (mode == kModeMain)
      {
        float3 n = sdf_normal(p, master_sdf, 0.01f, id);
        float3 lightPos = ro + float3(0.0f, 1.0f, 0.0f);
        float3 lightDir = normalize(p - lightPos);
        float3 shaded = max(pow(dot(n, -lightDir), 1.0f), kAmbient) * kDiffuse;
        float3 fresnel = 0.3f * pow(saturate(1.0f - dot(n, -rd)), 2.0f);
        float3 specular = 0.2f * pow(saturate(dot(n, -normalize(rd + lightDir))), 100.0f);

        return float4(shaded + fresnel + specular, d);
      }
      else if (mode == kModeStepCount)
      {
        return iStep;
      }
      else if (mode == kModeShapeCount)
      {
        // TODO
        return 0.0f;
      }
    }

    // hit background?
    if (dist > maxDist)
    {
      if (mode == kModeMain)
      {
        return float4(backgroundColor.rgb, kInfinity);
      }
      else
      {
        return iStep;
      }
    }

    dist += d;
  }

  if (mode != kModeMain)
    return kInfinity;

  return float4(missColor.rgb, kInfinity);
}

//-----------------------------------------------------------------------------
// end: ray marching


// kernels
//-----------------------------------------------------------------------------

#pragma kernel Main
#pragma kernel StepCountPerThread
#pragma kernel StepCountPerTile
#pragma kernel ShapeCountPerThread
#pragma kernel ShapeCountPerTile

[numthreads(kTileSize, kTileSize, 1)]
void Main(int3 id : SV_DispatchThreadID)
{
  if (any(id.xy > screenSize))
    return;

  float4 res = march(id, kModeMain);
  float3 col = res.rgb;

  dst[id.xy] = float4(col, 1.0f);
}

[numthreads(kTileSize, kTileSize, 1)]
void StepCountPerThread(int3 id : SV_DispatchThreadID)
{
  if (any(id.xy >= screenSize))
    return;
  
  float4 res = march(id, kModeStepCount);
  float heat = res.x / maxCountBudget;
  float3 col = heat_color(heat);

  dst[id.xy] = lerp(dst[id.xy], float4(col, 1.0f), heatAlpha);
}

[numthreads(kTileSize, kTileSize, 1)]
void StepCountPerTile(int3 id : SV_DispatchThreadID)
{
  float4 res = march(id, kModeStepCount);
  float heat = res.x / maxCountBudget;
  heatMap[id.xy] = heat;

  AllMemoryBarrierWithGroupSync();

  if (any(id.xy >= screenSize))
    return;

  int2 tileBaseId = kTileSize * (uint2(id.xy) / kTileSize);
  float maxHeat = 0.0f;
  for (int i = 0; i < kTileSize; ++i)
    for (int j = 0; j < kTileSize; ++j)
      maxHeat = max(maxHeat, heatMap[tileBaseId + int2(i, j)]);

  float3 col = heat_color(maxHeat);

  dst[id.xy] = lerp(dst[id.xy], float4(col, 1.0f), heatAlpha);
}

[numthreads(kTileSize, kTileSize, 1)]
void ShapeCountPerThread(int3 id : SV_DispatchThreadID)
{
  if (any(id.xy >= screenSize))
    return;

  float4 res = march(id, kModeShapeCount);
  float heat = res.x / maxCountBudget;
  float3 col = heat_color(heat);

  dst[id.xy] = lerp(dst[id.xy], float4(col, 1.0f), heatAlpha);
}

[numthreads(kTileSize, kTileSize, 1)]
void ShapeCountPerTile(int3 id : SV_DispatchThreadID)
{
  if (any(id.xy > screenSize))
    return;

  float4 res = march(id, kModeShapeCount);
  float3 col = heat_color(res.x);

  dst[id.xy] = lerp(dst[id.xy], float4(col, 1.0f), heatAlpha);
}

//-----------------------------------------------------------------------------
// end: kernels

